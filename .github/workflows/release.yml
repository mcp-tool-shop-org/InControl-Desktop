# InControl-Desktop Release Pipeline
#
# This workflow builds, tests, packages, and publishes releases.
# Releases are repeatable, verifiable, and boring.
#
# Trigger: Push a tag matching 'v*' (e.g., v1.0.0)

name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to build (without v prefix)'
        required: true
        type: string

env:
  DOTNET_VERSION: '9.0.x'
  CONFIGURATION: Release
  RUNTIME: win-x64

jobs:
  build:
    name: Build & Test
    runs-on: windows-latest

    outputs:
      version: ${{ steps.version.outputs.version }}
      version_suffix: ${{ steps.version.outputs.suffix }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for version info

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Extract Version
        id: version
        shell: pwsh
        run: |
          if ('${{ github.event.inputs.version }}') {
            $version = '${{ github.event.inputs.version }}'
          } else {
            $tag = '${{ github.ref_name }}'
            $version = $tag -replace '^v', ''
          }

          # Parse version components
          if ($version -match '^(\d+\.\d+\.\d+)(-(.+))?$') {
            $baseVersion = $matches[1]
            $suffix = if ($matches[3]) { $matches[3] } else { '' }
          } else {
            Write-Error "Invalid version format: $version"
            exit 1
          }

          echo "version=$version" >> $env:GITHUB_OUTPUT
          echo "base=$baseVersion" >> $env:GITHUB_OUTPUT
          echo "suffix=$suffix" >> $env:GITHUB_OUTPUT

          Write-Host "Version: $version"
          Write-Host "Base: $baseVersion"
          Write-Host "Suffix: $suffix"

      - name: Restore Dependencies
        run: dotnet restore

      - name: Build
        run: |
          dotnet build --configuration ${{ env.CONFIGURATION }} --no-restore `
            -p:Version=${{ steps.version.outputs.version }} `
            -p:AssemblyVersion=${{ steps.version.outputs.base }}.0 `
            -p:FileVersion=${{ steps.version.outputs.base }}.${{ github.run_number }}

      - name: Test
        run: dotnet test --configuration ${{ env.CONFIGURATION }} --no-build --verbosity normal

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-output
          path: |
            src/*/bin/${{ env.CONFIGURATION }}/**/*
          retention-days: 7

  package:
    name: Package MSIX
    runs-on: windows-latest
    needs: build

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Install Windows SDK
        shell: pwsh
        run: |
          # Windows SDK is pre-installed on windows-latest
          # Verify makeappx is available
          $makeappx = "C:\Program Files (x86)\Windows Kits\10\bin\10.0.22621.0\x64\makeappx.exe"
          if (Test-Path $makeappx) {
            Write-Host "Windows SDK found"
          } else {
            Write-Host "::warning::Windows SDK path may differ"
          }

      - name: Publish Application
        run: |
          dotnet publish src/InControl.App/InControl.App.csproj `
            --configuration ${{ env.CONFIGURATION }} `
            --runtime ${{ env.RUNTIME }} `
            --self-contained true `
            -p:PublishSingleFile=false `
            -p:Version=${{ needs.build.outputs.version }} `
            --output ./publish

      - name: Generate Build Metadata
        shell: pwsh
        run: |
          $metadata = @{
            version = '${{ needs.build.outputs.version }}'
            commit = '${{ github.sha }}'
            commitShort = '${{ github.sha }}'.Substring(0, 8)
            branch = '${{ github.ref_name }}'
            buildNumber = ${{ github.run_number }}
            buildTime = (Get-Date -Format 'o')
            runner = '${{ runner.os }}'
          }

          $metadata | ConvertTo-Json -Depth 10 | Out-File -FilePath ./publish/build-metadata.json -Encoding utf8

          Write-Host "Build metadata:"
          $metadata | ConvertTo-Json

      - name: Create MSIX Package (Unsigned)
        shell: pwsh
        run: |
          $version = '${{ needs.build.outputs.version }}'

          # For MSIX, version must be x.y.z.w format
          $msixVersion = $version -replace '-.*', ''
          if ($msixVersion -notmatch '^\d+\.\d+\.\d+\.\d+$') {
            $msixVersion = "$msixVersion.0"
          }

          Write-Host "MSIX Version: $msixVersion"

          # Create AppxManifest.xml from template
          $manifest = Get-Content -Path packaging/AppxManifest.template.xml -Raw
          $manifest = $manifest -replace '\$\{VERSION\}', $msixVersion
          $manifest = $manifest -replace '\$\{PUBLISHER\}', 'CN=InControl-Desktop'
          $manifest | Out-File -FilePath ./publish/AppxManifest.xml -Encoding utf8

          # Package using makeappx
          $makeappx = Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits\10\bin\*\x64\makeappx.exe" |
            Sort-Object { [version]($_.Directory.Parent.Name) } -Descending |
            Select-Object -First 1

          if (-not $makeappx) {
            Write-Error "makeappx.exe not found"
            exit 1
          }

          $outputPath = "./artifacts/InControl-Desktop-$version-unsigned.msix"
          New-Item -ItemType Directory -Force -Path ./artifacts | Out-Null

          & $makeappx.FullName pack /d ./publish /p $outputPath /nv

          if ($LASTEXITCODE -ne 0) {
            Write-Error "makeappx failed"
            exit 1
          }

          Write-Host "Created: $outputPath"

      - name: Generate Checksums
        shell: pwsh
        run: |
          $version = '${{ needs.build.outputs.version }}'
          $checksumFile = "./artifacts/checksums-$version.txt"

          Get-ChildItem -Path ./artifacts -Filter *.msix | ForEach-Object {
            $hash = (Get-FileHash -Path $_.FullName -Algorithm SHA256).Hash
            "$hash  $($_.Name)" | Out-File -FilePath $checksumFile -Append
          }

          Write-Host "Checksums:"
          Get-Content $checksumFile

      - name: Upload Package Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-package
          path: |
            artifacts/*.msix
            artifacts/checksums-*.txt
          retention-days: 90

  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [build, package]
    if: startsWith(github.ref, 'refs/tags/v')

    permissions:
      contents: write

    steps:
      - name: Download Artifacts
        uses: actions/download-artifact@v4
        with:
          name: release-package
          path: artifacts

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          name: InControl-Desktop v${{ needs.build.outputs.version }}
          draft: true  # Always draft first for review
          prerelease: ${{ needs.build.outputs.version_suffix != '' }}
          generate_release_notes: true
          files: |
            artifacts/*.msix
            artifacts/checksums-*.txt
          body: |
            ## InControl-Desktop v${{ needs.build.outputs.version }}

            ### Installation

            1. Download the MSIX package below
            2. Verify the SHA256 checksum
            3. Double-click to install

            ### Verification

            ```powershell
            # Verify checksum
            (Get-FileHash InControl-Desktop-${{ needs.build.outputs.version }}-unsigned.msix -Algorithm SHA256).Hash
            ```

            ### Build Information

            - **Commit:** ${{ github.sha }}
            - **Build:** #${{ github.run_number }}
            - **Workflow:** ${{ github.workflow }}

            ---

            ⚠️ **Note:** This is an unsigned build. Production releases will be signed.
